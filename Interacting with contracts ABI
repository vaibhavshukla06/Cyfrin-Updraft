// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

// import "./SimpleStorage.sol";  or |
// import {SimpleStorage, SimpleStorage2} from "./SimpleStorage.sol";
import {SimpleStorage} from "./SimpleStorage.sol";

contract StorageFactory {
    // uint256 public favoriteNumber
    // type visibility name
    SimpleStorage[] public listOfSimpleStorageContracts;

    function createSimpleStorageContract() public {
        SimpleStorage newSimpleStorageContract = new SimpleStorage();
        listOfSimpleStorageContracts.push(newSimpleStorageContract);
    }

    function sfStore(uint256 _simpleStorageIndex, uint256 _newSimpleStorageNumber) public {
        // üëÄ‚ùóIMPORTANT
        // Every time you have to interact with another contract, you need:
        //  1. the contract **address** 
        //  2. the contract **ABI (Application Binary Interface)**: a standardized way for interacting with the binary version of a smart contract deployed on the blockchain. It specifies the functions, their parameters, and the structure of the data that can be used to interact with the contract. It's generated by the compiler.

        // üóíÔ∏è NOTE :
        // If you do not have the full ABI available, a function selector will suffice (see later in the course).


        SimpleStorage mySimpleStorage = listOfSimpleStorageContracts[_simpleStorageIndex];
        mySimpleStorage.store(_newSimpleStorageNumber);
        // -------------------- or ---------------------           
        // listOfSimpleStorageContracts[_simpleStorageIndex].store( _newSimpleStorageNumber);
    }

    // ---------------------------- or ----------------------------          
    // function getFavoriteNumber() public view returns (uint256) {
    //     return listOfSimpleStorageContracts[0].retrieve();
    // }

    // üîç Explanation:
    // listOfSimpleStorageContracts is an array holding deployed SimpleStorage contracts.
    // [0] accesses the first contract in that array.
    // .retrieve() is a function from the SimpleStorage contract that returns the stored number.

    // So this function simply:
    // ‚û°Ô∏è Returns the favorite number stored in the first deployed contract.

    // ‚ö†Ô∏è Problem: It‚Äôs hardcoded
    // Only works for the first contract (index 0)
    // Useless if you have 2nd, 3rd, 10th contract
    // Doesn‚Äôt scale if you're using this as a factory

    // ------------------------ or ------------------------
    function sfGet(uint256 _simpleStorageIndex) public view returns(uint256) {
        SimpleStorage mySimpleStorage = listOfSimpleStorageContracts[_simpleStorageIndex];
        return mySimpleStorage.retrieve();
    }

    // üîç Explanation:
    // Takes a parameter: _simpleStorageIndex, like 0, 1, 2, etc.

    // Grabs the contract at that index in the array
    // Calls .retrieve() on it and Returns the number stored in that specific contract

    // ‚úÖ Why is this better?
    // getFavoriteNumber()	sfGet(_index)
    // Always returns from contract[0]	Can return from any contract[index]
    // Not dynamic Dynamic and reusable
    // Less useful in production	Very useful for managing many contracts

    // üéØ Analogy:
    // Think of it like having a list of lockers.

    // getFavoriteNumber() ‚Üí Always opens locker 0, even if you stored your stuff in locker 3.

    // sfGet(3) ‚Üí Opens locker 3, where your actual stuff might be.

    // üß† Conclusion:
    // getFavoriteNumber() = OK for testing or quick checks.

    // sfGet(_index) = Proper, reusable, scalable code.

    // ‚úÖ Use sfGet in real apps, especially when working with multiple contracts from a factory pattern.

}
